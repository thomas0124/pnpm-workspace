name: Deploy Preview Environment

on:
  pull_request:
    types: [opened, synchronize, reopened, closed]

env:
  PNPM_VERSION: "9.15.5"
  NODE_VERSION: "20"
  CLOUDFLARE_WORKERS_SUBDOMAIN: "sekibun3109"
  WRANGLER_VERSION: "4.51.0"

jobs:
  deploy-preview:
    runs-on: ubuntu-latest
    name: Deploy Preview to Cloudflare
    if: github.event.action != 'closed'
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Clean build cache
        run: |
          echo "üßπ Cleaning build cache..."
          rm -rf packages/backend/dist
          rm -rf packages/frontend/.next
          rm -rf packages/frontend/out
          echo "‚úÖ Cache cleaned"

      - name: Build packages
        run: pnpm run build

      - name: Setup Cloudflare Wrangler
        run: pnpm add -g wrangler@${{ env.WRANGLER_VERSION }}

      - name: Create or get D1 database
        id: d1-setup
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # PRÁï™Âè∑„Çí‰Ωø„Å£„Åü‰∏ÄÊÑè„ÅÆ„Éá„Éº„Çø„Éô„Éº„ÇπÂêç
          DB_NAME="ar-pamph-db-pr-${{ github.event.pull_request.number }}"
          echo "DB_NAME=$DB_NAME" >> $GITHUB_OUTPUT

          # Êó¢Â≠ò„ÅÆ„Éá„Éº„Çø„Éô„Éº„Çπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          DB_LIST=$(wrangler d1 list --json || echo "[]")
          DB_ID=$(echo "$DB_LIST" | jq -r ".[] | select(.name==\"$DB_NAME\") | .uuid" || echo "")

          # Êó¢Â≠òDB„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÂâäÈô§
          if [ -n "$DB_ID" ]; then
            echo "üóëÔ∏è Deleting existing database: $DB_NAME (ID: $DB_ID)"
            wrangler d1 delete "$DB_NAME" -y
            echo "‚úÖ Existing database deleted"
          fi

          # Êñ∞Ë¶è„Éá„Éº„Çø„Éô„Éº„Çπ„Çí‰ΩúÊàê
          echo "Creating new D1 database: $DB_NAME"
          wrangler d1 create "$DB_NAME"
          
          # „Éá„Éº„Çø„Éô„Éº„Çπ‰ΩúÊàê„ÅÆÂèçÊò†„ÇíÂæÖ„Å§Ôºà„É™„Éà„É©„Ç§ÔºãÊåáÊï∞„Éê„ÉÉ„ÇØ„Ç™„ÉïÔºâ
          for i in {1..5}; do
            DB_ID=$(wrangler d1 list --json | jq -r ".[] | select(.name==\"$DB_NAME\") | .uuid")
            if [ -n "$DB_ID" ]; then
              echo "Created database with ID: $DB_ID"
              break
            fi
            echo "Waiting for database to be available (attempt $i/5)..."
            sleep $((2 ** i))
          done
          
          if [ -z "$DB_ID" ]; then
            echo "Error: Failed to retrieve database ID after creation"
            exit 1
          fi
          
          # Â∏∏„Å´Êñ∞Ë¶è‰ΩúÊàê„Éï„É©„Ç∞„ÇíË®≠ÂÆö
          echo "IS_NEW_DB=true" >> $GITHUB_OUTPUT
          echo "‚úÖ New database created"
          echo "DB_ID=$DB_ID" >> $GITHUB_OUTPUT

      - name: Update wrangler.toml with D1 database ID
        working-directory: packages/backend
        run: |
          # PreviewÁí∞Â¢É„ÅÆdatabase_name„Å®database_id„ÇíÂãïÁöÑ„Å´Ë®≠ÂÆö
          DB_NAME="${{ steps.d1-setup.outputs.DB_NAME }}"
          DB_ID="${{ steps.d1-setup.outputs.DB_ID }}"
          
          # ÂÖÉ„ÅÆwrangler.toml„Çí„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºà„ÉÅ„Çß„ÉÉ„ÇØ„Ç¢„Ç¶„ÉàÊôÇÁÇπ„ÅÆÁä∂ÊÖã„Çí‰øùÊåÅÔºâ
          cp wrangler.toml wrangler.toml.original
          
          # „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó„Åã„Çâ‰∏ÄÊôÇÁöÑ„Å™wrangler.toml„Çí‰ΩúÊàêÔºàÂ∏∏„Å´ÂÖÉ„ÅÆÁä∂ÊÖã„Åã„ÇâÈñãÂßãÔºâ
          cp wrangler.toml.original wrangler.toml
          
          # env.preview.d1_databases„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„ÅÆdatabase_name„ÇíÊõ¥Êñ∞
          sed -i "s|database_name = \"ar-pamph-db-preview\"|database_name = \"$DB_NAME\"|" wrangler.toml
          
          # env.preview.d1_databases„Çª„ÇØ„Ç∑„Éß„É≥ÂÜÖ„ÅÆdatabase_id„ÇíÊõ¥Êñ∞
          # [[env.preview.d1_databases]]„Åã„ÇâÊ¨°„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„Åæ„Åß„ÅÆÁØÑÂõ≤„Åßdatabase_id„ÇíÁΩÆÊèõ
          sed -i "/\[\[env\.preview\.d1_databases\]\]/,/^\[\[/ s|database_id = \"\"|database_id = \"$DB_ID\"|" wrangler.toml
          cat wrangler.toml

      - name: Run D1 Database Migrations
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # ‰∏ÄÊôÇÁöÑ„Å™wrangler.toml„Åå‰ΩøÁî®„Åï„Çå„ÇãÔºàÂâç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Åß‰ΩúÊàêÊ∏à„ÅøÔºâ
          IS_NEW_DB="${{ steps.d1-setup.outputs.IS_NEW_DB }}"
          
          # „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åô„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
          if [ ! -d "infrastructure/persistence/drizzle/migrations" ] || [ -z "$(ls -A infrastructure/persistence/drizzle/migrations/*.sql 2>/dev/null)" ]; then
            echo "‚ÑπÔ∏è No migrations found, skipping..."
            exit 0
          fi
          
          echo "üì¶ Checking database migrations..."
          
          if [ "$IS_NEW_DB" = "true" ]; then
            echo "üÜï New database detected - applying all migrations"
          else
            echo "‚ôªÔ∏è Existing database detected - checking for unapplied migrations"
            
            # ÈÅ©Áî®Ê∏à„Åø„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Çí„É™„Çπ„Éà
            APPLIED_MIGRATIONS=$(wrangler d1 migrations list ${{ steps.d1-setup.outputs.DB_NAME }} --remote --env preview 2>/dev/null | grep -E "^\d{4}_" | awk '{print $1}' || echo "")
            
            # „É≠„Éº„Ç´„É´„ÅÆ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´„Çí„É™„Çπ„Éà
            LOCAL_MIGRATIONS=$(ls infrastructure/persistence/drizzle/migrations/*.sql 2>/dev/null | xargs -n 1 basename || echo "")
            
            # Êú™ÈÅ©Áî®„ÅÆ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Åå„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            UNAPPLIED_COUNT=0
            for migration in $LOCAL_MIGRATIONS; do
              if ! echo "$APPLIED_MIGRATIONS" | grep -q "^${migration}$"; then
                UNAPPLIED_COUNT=$((UNAPPLIED_COUNT + 1))
                echo "  ‚è≥ Unapplied: $migration"
              fi
            done
            
            if [ $UNAPPLIED_COUNT -eq 0 ]; then
              echo "‚úÖ All migrations already applied - database is up to date"
              exit 0
            fi
            
            echo "üìù Found $UNAPPLIED_COUNT unapplied migration(s)"
          fi
          
          # „Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥ÈÅ©Áî®
          echo "üöÄ Applying migrations..."
          if wrangler d1 migrations apply ${{ steps.d1-setup.outputs.DB_NAME }} --remote --env preview 2>&1 | tee /tmp/migration_output.log; then
            echo "‚úÖ Migrations applied successfully"
          else
            MIGRATION_ERROR=$(cat /tmp/migration_output.log)
            echo "‚ùå Migration failed with error:"
            echo "$MIGRATION_ERROR"
            exit 1
          fi

      - name: Seed D1 Database
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # „É≠„Éº„Ç´„É´„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥„Å®„Ç∑„Éº„Éâ„ÅØ„Éá„Éï„Ç©„É´„ÉàDB„Çí‰ΩøÁî®„Åô„Çã„Åå„ÄÅ
          # „É™„É¢„Éº„ÉàD1„Å∏„ÅÆÈÅ©Áî®„ÅØ‰∏ÄÊôÇÁöÑ„Å™wrangler.toml„ÅÆË®≠ÂÆö„Çí‰ΩøÁî®„Åô„Çã
          IS_NEW_DB="${{ steps.d1-setup.outputs.IS_NEW_DB }}"
          
          if [ "$IS_NEW_DB" = "true" ]; then
            if [ -f "infrastructure/persistence/drizzle/seeds/index.ts" ]; then
              echo "üå± Preparing seed data..."
              
              # „É≠„Éº„Ç´„É´„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥
              pnpm db:migrate:local
              
              # „É≠„Éº„Ç´„É´„ÅßseedÂÆüË°å
              pnpm run db:seed
              
              # „É≠„Éº„Ç´„É´DB„Åã„Çâ„Éá„Éº„Çø„Çí„ÉÄ„É≥„Éó
              LATEST_DB=$(ls -t .wrangler/state/v3/d1/miniflare-D1DatabaseObject/*.sqlite | head -1)
              
              if [ -n "$LATEST_DB" ]; then
                echo "üì¶ Extracting seed data..."
                # Â§ñÈÉ®„Ç≠„ÉºÂà∂Á¥Ñ„ÇíÁÑ°ÂäπÂåñ
                echo "PRAGMA foreign_keys=OFF;" > full-dump.sql
                # „Éá„Éº„Çø„ÅÆ„Åø„ÉÄ„É≥„ÉóÔºàÂÜÖÈÉ®„ÉÜ„Éº„Éñ„É´Èô§Â§ñÔºâ
                sqlite3 "$LATEST_DB" .dump | \
                  grep "^INSERT" | \
                  grep -v "d1_migrations" | \
                  grep -v "_cf_" >> full-dump.sql
                # Â§ñÈÉ®„Ç≠„ÉºÂà∂Á¥Ñ„ÇíÂÜçÂ∫¶ÊúâÂäπÂåñ
                echo "PRAGMA foreign_keys=ON;" >> full-dump.sql
                
                # „É™„É¢„Éº„ÉàD1„Å´ÈÅ©Áî®
                echo "üì§ Seeding remote D1..."
                wrangler d1 execute ${{ steps.d1-setup.outputs.DB_NAME }} \
                  --remote \
                  --env preview \
                  --file=full-dump.sql
                
                echo "‚úÖ Seed complete"
              else
                echo "‚ùå Local DB not found"
                exit 1
              fi
            else
              echo "‚ÑπÔ∏è No seed file, skipping..."
            fi
          else
            echo "‚ÑπÔ∏è Skipping seed for existing database"
          fi

      - name: Set JWT_SECRET secret
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "üîê Setting JWT_SECRET secret for preview environment..."
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env preview
          echo "‚úÖ JWT_SECRET secret set successfully"

      - name: Deploy Backend to Cloudflare Workers
        id: deploy-backend
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # ‰∏ÄÊôÇÁöÑ„Å™wrangler.toml„Åå‰ΩøÁî®„Åï„Çå„ÇãÔºàÂâç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Åß‰ΩúÊàêÊ∏à„ÅøÔºâ
          # PreviewÁí∞Â¢É„Å´„Éá„Éó„É≠„Ç§ÔºàÈÄöÂ∏∏„ÅÆ„Éê„É≥„Éâ„É´„É¢„Éº„ÉâÔºâ
          # TypeScript„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„ÉàÔºàindex.tsÔºâ„ÇíWrangler„Å´„Éê„É≥„Éâ„É´„Åï„Åõ„Çã
          echo "üöÄ Deploying backend (with bundling)..."
          DEPLOY_OUTPUT=$(wrangler deploy --env preview)
          echo "$DEPLOY_OUTPUT"

          # Áí∞Â¢ÉÂ§âÊï∞„Å®WorkerÂêç„Åã„ÇâÊòéÁ§∫ÁöÑ„Å´URL„ÇíÁîüÊàê
          WORKER_NAME="ar-pamph-preview"
          WORKER_URL="https://${WORKER_NAME}.${CLOUDFLARE_WORKERS_SUBDOMAIN}.workers.dev"
          
          echo "WORKER_URL=$WORKER_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend deployed to: $WORKER_URL"

      - name: Build Frontend
        working-directory: packages/frontend
        env:
          NEXT_PUBLIC_API_URL: ${{ steps.deploy-backend.outputs.WORKER_URL }}
        run: |
          echo "üßπ Cleaning frontend cache..."
          rm -rf .next out
          echo "Building frontend with API URL: $NEXT_PUBLIC_API_URL"
          pnpm run build

      - name: Create Cloudflare Pages project if not exists
        working-directory: packages/frontend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Êó¢Â≠ò„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÁ¢∫Ë™ç
          PROJECTS=$(wrangler pages project list 2>/dev/null || echo "")
          PROJECT_EXISTS=$(echo "$PROJECTS" | grep -q "ar-pamph" && echo "exists" || echo "")
          
          if [ -z "$PROJECT_EXISTS" ]; then
            echo "Creating Cloudflare Pages project: ar-pamph"
            wrangler pages project create ar-pamph --production-branch=main
          else
            echo "Project ar-pamph already exists"
          fi

      - name: Deploy Frontend to Cloudflare Pages
        id: deploy-frontend
        working-directory: packages/frontend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Cloudflare Pages„Å´„Éá„Éó„É≠„Ç§ÔºàÈùôÁöÑ„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Åï„Çå„Åüout„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí„Éá„Éó„É≠„Ç§Ôºâ
          wrangler pages deploy out --project-name=ar-pamph --branch=preview-pr-${{ github.event.pull_request.number }}

          # „Éá„Éó„É≠„Ç§„Åï„Çå„ÅüURL„ÇíÁîüÊàê
          PAGES_URL="https://preview-pr-${{ github.event.pull_request.number }}.ar-pamph.pages.dev"
          echo "PAGES_URL=$PAGES_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend deployed to: $PAGES_URL"

      - name: Comment PR with deployment URLs
        uses: actions/github-script@v7
        env:
          FRONTEND_URL: ${{ steps.deploy-frontend.outputs.PAGES_URL }}
          BACKEND_URL: ${{ steps.deploy-backend.outputs.WORKER_URL }}
          DB_NAME: ${{ steps.d1-setup.outputs.DB_NAME }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const frontendUrl = process.env.FRONTEND_URL;
            const backendUrl = process.env.BACKEND_URL;
            const dbName = process.env.DB_NAME;

            const comment = `## üöÄ Preview Environment Deployed!

            ### üì± Frontend
            ${frontendUrl}

            ### ‚öôÔ∏è Backend API
            ${backendUrl}

            ### üóÑÔ∏è Database
            D1 Database: \`${dbName}\` (üÜï Êñ∞Ë¶è‰ΩúÊàê)

            ---

            PreviewÁí∞Â¢É„ÅåÊ≠£Â∏∏„Å´„Éá„Éó„É≠„Ç§„Åï„Çå„Åæ„Åó„ÅüÔºÅ
            ÂêÑURL„Å´„Ç¢„ÇØ„Çª„Çπ„Åó„Å¶Âãï‰Ωú„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

            *„Åì„ÅÆPreviewÁí∞Â¢É„ÅØPR„Åå„Éû„Éº„Ç∏„Åæ„Åü„ÅØ„ÇØ„É≠„Éº„Ç∫„Åï„Çå„Çã„Åæ„ÅßÂà©Áî®ÂèØËÉΩ„Åß„Åô„ÄÇ*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  cleanup-preview:
    runs-on: ubuntu-latest
    name: Cleanup Preview Environment
    if: github.event.action == 'closed'
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Setup Cloudflare Wrangler
        run: pnpm add -g wrangler@${{ env.WRANGLER_VERSION }}

      - name: Delete D1 database
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # PRÁï™Âè∑„Åã„Çâ„Éá„Éº„Çø„Éô„Éº„ÇπÂêç„ÇíÁîüÊàê
          DB_NAME="ar-pamph-db-pr-${{ github.event.pull_request.number }}"
          echo "üóëÔ∏è Checking for database: $DB_NAME"

          # Êó¢Â≠ò„ÅÆ„Éá„Éº„Çø„Éô„Éº„Çπ„Çí„ÉÅ„Çß„ÉÉ„ÇØ
          DB_LIST=$(wrangler d1 list --json || echo "[]")
          DB_ID=$(echo "$DB_LIST" | jq -r ".[] | select(.name==\"$DB_NAME\") | .uuid" 2>/dev/null || echo "")

          if [ -z "$DB_ID" ]; then
            echo "‚ö†Ô∏è Database $DB_NAME not found. It may have already been deleted."
          else
            echo "Found database: $DB_NAME (ID: $DB_ID)"
            echo "Deleting database..."
            if wrangler d1 delete "$DB_NAME" -y; then
              echo "‚úÖ Successfully deleted database: $DB_NAME"
            else
              echo "‚ö†Ô∏è Failed to delete database: $DB_NAME"
              echo "This may be because the database was already deleted or does not exist."
            fi
          fi

      - name: Delete Cloudflare Worker deployment
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          WORKER_NAME="ar-pamph-preview"
          echo "üóëÔ∏è Checking for Cloudflare Worker: $WORKER_NAME (preview environment)"

          # Worker„ÅåÂ≠òÂú®„Åô„Çã„ÅãÁ¢∫Ë™ç
          if wrangler deployments list --env preview 2>/dev/null | grep -q "$WORKER_NAME"; then
            echo "Found Worker deployment. Attempting to delete..."
            # Worker„ÅÆÂâäÈô§ÔºàpreviewÁí∞Â¢ÉÔºâ
            if wrangler delete "$WORKER_NAME" --env preview --force 2>/dev/null; then
              echo "‚úÖ Successfully deleted Worker: $WORKER_NAME (preview)"
            else
              echo "‚ö†Ô∏è Failed to delete Worker: $WORKER_NAME (preview)"
              echo "This may be because the Worker was already deleted or does not exist."
            fi
          else
            echo "‚ö†Ô∏è Worker $WORKER_NAME (preview) not found. It may have already been deleted."
          fi

      - name: Delete Cloudflare Pages deployment
        working-directory: packages/frontend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          PROJECT_NAME="ar-pamph"
          BRANCH_NAME="preview-pr-${{ github.event.pull_request.number }}"
          echo "üóëÔ∏è Checking for Cloudflare Pages deployment: $PROJECT_NAME (branch: $BRANCH_NAME)"

          # Pages„ÅÆ„Éá„Éó„É≠„Ç§„É°„É≥„Éà‰∏ÄË¶ß„ÇíÂèñÂæó
          DEPLOYMENTS=$(wrangler pages deployment list --project-name="$PROJECT_NAME" --json 2>/dev/null || echo "[]")
          
          # Ë©≤ÂΩì„Åô„Çã„Éñ„É©„É≥„ÉÅ„ÅÆ„Éá„Éó„É≠„Ç§„É°„É≥„Éà„ÇíÊ§úÁ¥¢
          DEPLOYMENT_ID=$(echo "$DEPLOYMENTS" | jq -r ".[] | select(.branch==\"$BRANCH_NAME\") | .id" 2>/dev/null | head -n 1)

          if [ -z "$DEPLOYMENT_ID" ] || [ "$DEPLOYMENT_ID" == "null" ]; then
            echo "‚ö†Ô∏è Pages deployment for branch $BRANCH_NAME not found. It may have already been deleted."
          else
            echo "Found Pages deployment: $DEPLOYMENT_ID (branch: $BRANCH_NAME)"
            echo "Deleting Pages deployment..."
            # Pages„ÅÆ„Éá„Éó„É≠„Ç§„É°„É≥„ÉàÂâäÈô§ÔºàAPI„Çí‰ΩøÁî®Ôºâ
            if curl -X DELETE \
              "https://api.cloudflare.com/client/v4/accounts/$CLOUDFLARE_ACCOUNT_ID/pages/projects/$PROJECT_NAME/deployments/$DEPLOYMENT_ID" \
              -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
              -H "Content-Type: application/json" 2>/dev/null | grep -q '"success":true'; then
              echo "‚úÖ Successfully deleted Pages deployment: $DEPLOYMENT_ID"
            else
              echo "‚ö†Ô∏è Failed to delete Pages deployment: $DEPLOYMENT_ID"
              echo "This may be because the deployment was already deleted or does not exist."
            fi
          fi