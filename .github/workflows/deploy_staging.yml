name: Deploy to Staging Environment

on:
  push:
    branches:
      - develop

env:
  PNPM_VERSION: "9.15.5"
  NODE_VERSION: "20"
  CLOUDFLARE_WORKERS_SUBDOMAIN: "sekibun3109"
  WRANGLER_VERSION: "4.51.0"

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    name: Deploy to Staging (Cloudflare)
    permissions:
      contents: read
      deployments: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build packages
        run: pnpm run build

      - name: Setup Cloudflare Wrangler
        run: pnpm add -g wrangler@${{ env.WRANGLER_VERSION }}

      - name: Create or get D1 database for Staging
        id: d1-setup
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          DB_NAME="ar-pamph-db-staging"
          echo "DB_NAME=$DB_NAME" >> $GITHUB_OUTPUT
          
          # æ—¢å­˜ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
          DB_LIST=$(wrangler d1 list --json || echo "[]")
          DB_ID=$(echo "$DB_LIST" | jq -r ".[] | select(.name==\"$DB_NAME\") | .uuid" || echo "")
          
          if [ -z "$DB_ID" ]; then
            echo "Creating new D1 database: $DB_NAME"
            wrangler d1 create "$DB_NAME"
            # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä½œæˆã®åæ˜ ã‚’å¾…ã¤ (exponential backoff)
            for i in {1..5}; do
              DB_ID=$(wrangler d1 list --json | jq -r ".[] | select(.name==\"$DB_NAME\") | .uuid")
              if [ -n "$DB_ID" ]; then
                break
              fi
              echo "Waiting for database to be available (attempt $i/5)..."
              sleep $((2 ** i))
            done
            if [ -z "$DB_ID" ]; then
              echo "Error: Failed to retrieve database ID after creation"
              exit 1
            fi
            # æ–°è¦ä½œæˆãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            echo "IS_NEW_DB=true" >> $GITHUB_OUTPUT
            echo "âœ… New database created with ID: $DB_ID"
          else
            echo "Using existing D1 database: $DB_NAME (ID: $DB_ID)"
            # æ—¢å­˜DBãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            echo "IS_NEW_DB=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Reusing existing database"
          fi
          
          echo "DB_ID=$DB_ID" >> $GITHUB_OUTPUT

      - name: Update wrangler.toml with D1 database ID
        working-directory: packages/backend
        run: |
          # Stagingç’°å¢ƒã®database_idã‚’å‹•çš„ã«è¨­å®š
          sed -i '/\[env\.staging\.d1_databases\]/,/database_id = ""/ s/database_id = ""/database_id = "${{ steps.d1-setup.outputs.DB_ID }}"/' wrangler.toml
          echo "Updated wrangler.toml:"
          cat wrangler.toml

      - name: Run D1 Database Migrations
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          IS_NEW_DB="${{ steps.d1-setup.outputs.IS_NEW_DB }}"
          
          # ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          if [ ! -d "infrastructure/persistence/drizzle/migrations" ] || [ -z "$(ls -A infrastructure/persistence/drizzle/migrations/*.sql 2>/dev/null)" ]; then
            echo "â„¹ï¸ No migrations found, skipping..."
            exit 0
          fi
          
          echo "ðŸ“¦ Checking database migrations..."
          
          if [ "$IS_NEW_DB" = "true" ]; then
            echo "ðŸ†• New database detected - applying all migrations"
          else
            echo "â™»ï¸ Existing database detected - checking for unapplied migrations"
            
            # é©ç”¨æ¸ˆã¿ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚¹ãƒˆ
            APPLIED_MIGRATIONS=$(wrangler d1 migrations list ${{ steps.d1-setup.outputs.DB_NAME }} --remote --env staging 2>/dev/null | grep -E "^\d{4}_" | awk '{print $1}' || echo "")
            
            # ãƒ­ãƒ¼ã‚«ãƒ«ã®ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒªã‚¹ãƒˆ
            LOCAL_MIGRATIONS=$(ls infrastructure/persistence/drizzle/migrations/*.sql 2>/dev/null | xargs -n 1 basename || echo "")
            
            # æœªé©ç”¨ã®ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            UNAPPLIED_COUNT=0
            for migration in $LOCAL_MIGRATIONS; do
              if ! echo "$APPLIED_MIGRATIONS" | grep -q "^${migration}$"; then
                UNAPPLIED_COUNT=$((UNAPPLIED_COUNT + 1))
                echo "  â³ Unapplied: $migration"
              fi
            done
            
            if [ $UNAPPLIED_COUNT -eq 0 ]; then
              echo "âœ… All migrations already applied - database is up to date"
              exit 0
            fi
            
            echo "ðŸ“ Found $UNAPPLIED_COUNT unapplied migration(s)"
          fi
          
          # ãƒžã‚¤ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é©ç”¨
          echo "ðŸš€ Applying migrations..."
          if wrangler d1 migrations apply ${{ steps.d1-setup.outputs.DB_NAME }} --remote --env staging 2>&1 | tee /tmp/migration_output.log; then
            echo "âœ… Migrations applied successfully"
          else
            MIGRATION_ERROR=$(cat /tmp/migration_output.log)
            echo "âŒ Migration failed with error:"
            echo "$MIGRATION_ERROR"
            exit 1
          fi

      - name: Set JWT_SECRET secret
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          echo "ðŸ” Setting JWT_SECRET secret for staging environment..."
          echo "${{ secrets.JWT_SECRET }}" | wrangler secret put JWT_SECRET --env staging
          echo "âœ… JWT_SECRET secret set successfully"

      - name: Deploy Backend to Cloudflare Workers (Staging)
        id: deploy-backend
        working-directory: packages/backend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Stagingç’°å¢ƒã«ãƒ‡ãƒ—ãƒ­ã‚¤
          DEPLOY_OUTPUT=$(wrangler deploy --env staging)
          echo "$DEPLOY_OUTPUT"
          
          # ç’°å¢ƒå¤‰æ•°ã¨Workeråã‹ã‚‰æ˜Žç¤ºçš„ã«URLã‚’ç”Ÿæˆ
          WORKER_NAME="ar-pamph-staging"
          WORKER_URL="https://${WORKER_NAME}.${CLOUDFLARE_WORKERS_SUBDOMAIN}.workers.dev"
          
          echo "WORKER_URL=$WORKER_URL" >> $GITHUB_OUTPUT
          echo "âœ… Backend deployed to: $WORKER_URL"

      - name: Build Frontend with Staging API URL
        working-directory: packages/frontend
        env:
          NEXT_PUBLIC_API_URL: ${{ steps.deploy-backend.outputs.WORKER_URL }}
        run: |
          echo "ðŸ§¹ Cleaning frontend cache..."
          rm -rf .next .open-next .vercel out
          echo "Building frontend with API URL: $NEXT_PUBLIC_API_URL"
          npx opennextjs-cloudflare build

      - name: Update wrangler.jsonc for staging environment
        working-directory: packages/frontend
        run: |
          # Stagingç’°å¢ƒç”¨ã®Workeråã‚’è¨­å®š
          WORKER_NAME="ar-pamph-frontend-staging"
          # wrangler.jsoncã®nameã‚’æ›´æ–°
          sed -i "s|\"name\": \"ar-pamph-frontend\"|\"name\": \"$WORKER_NAME\"|" wrangler.jsonc
          sed -i "s|\"service\": \"ar-pamph-frontend\"|\"service\": \"$WORKER_NAME\"|" wrangler.jsonc
          cat wrangler.jsonc

      - name: Deploy Frontend to Cloudflare Workers (Staging)
        id: deploy-frontend
        working-directory: packages/frontend
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Cloudflare Workersã«ãƒ‡ãƒ—ãƒ­ã‚¤
          wrangler deploy --config wrangler.jsonc
          
          # ãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚ŒãŸURLã‚’ç”Ÿæˆï¼ˆWorkers ã®URLï¼‰
          WORKER_NAME="ar-pamph-frontend-staging"
          FRONTEND_URL="https://${WORKER_NAME}.${CLOUDFLARE_WORKERS_SUBDOMAIN}.workers.dev"
          echo "FRONTEND_URL=$FRONTEND_URL" >> $GITHUB_OUTPUT
          echo "âœ… Frontend deployed to: $FRONTEND_URL"

      - name: Create deployment summary
        env:
          IS_NEW_DB: ${{ steps.d1-setup.outputs.IS_NEW_DB }}
        run: |
          DB_STATUS="â™»ï¸ æ—¢å­˜DBã‚’å†åˆ©ç”¨"
          if [ "$IS_NEW_DB" = "true" ]; then
            DB_STATUS="ðŸ†• æ–°è¦ä½œæˆ"
          fi
          
          echo "## ðŸš€ Staging Environment Deployed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“± Frontend" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.deploy-frontend.outputs.FRONTEND_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âš™ï¸ Backend API" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.deploy-backend.outputs.WORKER_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ—„ï¸ Database" >> $GITHUB_STEP_SUMMARY
          echo "D1 Database: \`${{ steps.d1-setup.outputs.DB_NAME }}\` (${DB_STATUS})" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "Deployed from: \`${{ github.ref }}\` @ \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY